use ark_crypto_primitives::sponge::Absorb;
use ark_ff::PrimeField;
use lattirust_arithmetic::challenge_set::latticefold_challenge_set::{
    LatticefoldChallengeSet, OverField,
};

use crate::transcript::Transcript;

use super::SumCheckError;
use super::SumCheckIP;
use super::SumCheckProof;

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: PrimeField, R: OverField<F>> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<R>,
    /// the expected evaluation
    pub expected_evaluation: R,
    // Phantom Data for the underlying field
    _marker: std::marker::PhantomData<F>,
}
pub struct SumCheckVerifier<F: PrimeField, R: OverField<F>, CS: LatticefoldChallengeSet<F, R>>
where
    F: Absorb,
{
    _marker: std::marker::PhantomData<(F, CS)>,
    protocol: SumCheckIP<F, R>,
}

impl<F: PrimeField, R: OverField<F>, CS: LatticefoldChallengeSet<F, R>> SumCheckVerifier<F, R, CS>
where
    F: Absorb,
{
    pub fn new(protocol: SumCheckIP<F, R>) -> SumCheckVerifier<F, R, CS> {
        SumCheckVerifier {
            _marker: std::marker::PhantomData,
            protocol,
        }
    }
    // Verifies the transcript
    // Returns evaluation subclaim,
    // returns an error otherwise.
    pub fn verify(
        &self,
        proof: &SumCheckProof<F, R>,
        transcript: &mut impl Transcript<F, R, ChallengeSet = CS>,
    ) -> Result<SumCheckSubClaim<F, R>, SumCheckError<R>> {
        let mut check_sum = self.protocol.claimed_sum;

        let mut challenge_vector: Vec<R> = Vec::with_capacity(proof.rounds.len());

        for round in proof.rounds.iter() {
            let eval1 = round.unipoly.evaluate(&[R::one()])?;
            let eval0 = round.unipoly.evaluate(&[R::zero()])?;
            let sum = eval1 + eval0;

            if sum != check_sum {
                return Err(SumCheckError::SumCheckFailed(sum, check_sum));
            } else if round.unipoly.aux_info.max_degree > self.protocol.poly_info.max_degree {
                return Err(SumCheckError::MaxDegreeExceeded);
            }

            let coeffs: Vec<R> = round
                .unipoly
                .products
                .clone()
                .into_iter()
                .map(|(x, _)| x)
                .collect();
            transcript.absorb_ring_vec(&coeffs);

            let challenge = transcript.get_big_challenge().into();

            // TODO: replace this with a saner type for the UV polys?
            check_sum = round.unipoly.evaluate(&[challenge])?;
            challenge_vector.push(challenge);
        }

        Ok(SumCheckSubClaim {
            expected_evaluation: check_sum,
            point: challenge_vector,
            _marker: Default::default(),
        })
    }
}
#[cfg(test)]
mod test {
    use std::sync::Arc;

    use super::SumCheckVerifier;
    use crate::{
        transcript::poseidon::PoseidonTranscript, utils::sumcheck::prover::SumCheckProver,
    };

    use ark_ff::{One, Zero};
    use lattirust_arithmetic::{
        challenge_set::latticefold_challenge_set::BinarySmallSet,
        mle::DenseMultilinearExtension,
        polynomials::VirtualPolynomial,
        ring::{Pow2CyclotomicPolyRingNTT, Zq},
    };

    #[test]
    fn test_sumcheck_protocol() {
        // Define the modulus Q and the dimension N
        const Q: u64 = 17; // Replace with an appropriate modulus
        const N: usize = 8; // Replace with an appropriate dimension

        // Example function to generate coefficients
        fn generate_coefficient_i(index: usize) -> Zq<Q> {
            Zq::<Q>::from(index as u64) // Simple example: use the index as the coefficient value
        }

        // Create an instance of Pow2CyclotomicPolyRingNTT using from_fn
        let poly_ntt = Pow2CyclotomicPolyRingNTT::<Q, N>::from_fn(generate_coefficient_i);

        let one = Pow2CyclotomicPolyRingNTT::<Q, N>::one();
        let zero = Pow2CyclotomicPolyRingNTT::<Q, N>::zero();
        let mle1 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[poly_ntt, poly_ntt, zero, zero, zero, zero, zero, zero],
        );
        let mle2 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, poly_ntt, poly_ntt, zero, zero, zero, zero],
        );
        let mle3 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, zero, zero, poly_ntt, poly_ntt, zero, zero],
        );
        let mle4 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, zero, zero, zero, zero, poly_ntt, poly_ntt],
        );
        let mut polynomial = VirtualPolynomial::new(3);
        let _ = polynomial.add_mle_list(
            vec![
                Arc::from(mle1.clone()),
                Arc::from(mle2),
                Arc::from(mle3),
                Arc::from(mle4),
            ],
            one,
        );
        let _ = polynomial.add_mle_list(vec![Arc::from(mle1)], one);
        // Define the claimed sum for testing
        let claimed_sum = poly_ntt + poly_ntt; // Example sum

        // Create an instance of the prover
        let prover = SumCheckProver::<Zq<Q>, Pow2CyclotomicPolyRingNTT<Q, N>, BinarySmallSet<Q, N>> {
            _marker: std::marker::PhantomData,
            polynomial: polynomial.clone(),
            claimed_sum: Into::into(claimed_sum),
        };

        let mut transcript = PoseidonTranscript::default();

        // Prove the statement
        let (protocol, proof) = prover.prove(&mut transcript).unwrap();

        let mut transcript = PoseidonTranscript::default();
        // Create an instance of the verifier
        let verifier =
            SumCheckVerifier::<Zq<Q>, Pow2CyclotomicPolyRingNTT<Q, N>, BinarySmallSet<Q, N>>::new(
                protocol,
            );

        // Verify the transcript
        let subclaim = verifier.verify(&proof, &mut transcript).unwrap();
        assert!(
            polynomial.evaluate(&subclaim.point).unwrap() == subclaim.expected_evaluation,
            "wrong subclaim"
        );
    }
    #[test]
    fn test_failing_sumcheck_protocol() {
        // Define the modulus Q and the dimension N
        const Q: u64 = 17; // Replace with an appropriate modulus
        const N: usize = 8; // Replace with an appropriate dimension

        // Example function to generate coefficients
        fn generate_coefficient_i(index: usize) -> Zq<Q> {
            Zq::<Q>::from(index as u64) // Simple example: use the index as the coefficient value
        }

        // Create an instance of Pow2CyclotomicPolyRingNTT using from_fn
        let poly_ntt = Pow2CyclotomicPolyRingNTT::<Q, N>::from_fn(generate_coefficient_i);

        let one = Pow2CyclotomicPolyRingNTT::<Q, N>::one();
        let zero = Pow2CyclotomicPolyRingNTT::<Q, N>::zero();
        let mle1 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[poly_ntt, poly_ntt, zero, zero, zero, zero, zero, zero],
        );
        let mle2 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, poly_ntt, poly_ntt, zero, zero, zero, zero],
        );
        let mle3 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, zero, zero, poly_ntt, poly_ntt, zero, zero],
        );
        let mle4 = DenseMultilinearExtension::from_evaluations_slice(
            3,
            &[zero, zero, zero, zero, zero, zero, poly_ntt, poly_ntt],
        );
        let mut polynomial = VirtualPolynomial::new(3);
        let _ = polynomial.add_mle_list(
            vec![
                Arc::from(mle1.clone()),
                Arc::from(mle2),
                Arc::from(mle3),
                Arc::from(mle4),
            ],
            one,
        );
        let _ = polynomial.add_mle_list(vec![Arc::from(mle1)], one);
        // Define the claimed sum for testing
        let claimed_sum = poly_ntt; // Example sum

        let mut transcript = PoseidonTranscript::default();
        // Create an instance of the prover
        let prover = SumCheckProver::<Zq<Q>, Pow2CyclotomicPolyRingNTT<Q, N>, BinarySmallSet<Q, N>> {
            _marker: std::marker::PhantomData,
            polynomial: polynomial.clone(),
            claimed_sum: Into::into(claimed_sum),
        };

        // Prove the statement
        let (protocol, proof) = prover.prove(&mut transcript).unwrap();

        // Create an instance of the verifier
        let verifier =
            SumCheckVerifier::<Zq<Q>, Pow2CyclotomicPolyRingNTT<Q, N>, BinarySmallSet<Q, N>>::new(
                protocol,
            );

        let mut transcript = PoseidonTranscript::default();
        // Verify the transcript
        let subclaim = verifier.verify(&proof, &mut transcript);
        assert!(
            subclaim.is_err(),
            "Wrong sumcheck claim should return error"
        );
    }
}
