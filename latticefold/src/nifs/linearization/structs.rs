use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::marker::PhantomData;

use cyclotomic_rings::rings::SuitableRing;

use crate::{
    arith::{Witness, CCCS, CCS, LCCCS},
    ark_base::*,
    nifs::error::LinearizationError,
    transcript::Transcript,
    utils::sumcheck,
};

use lattirust_ring::OverField;

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * linearization_sumcheck - A list of on-interactive sumcheck prover messages
/// * v - The MLE of f_hat evaluated at the sumcheck challenge point
/// * u - The MLEs of $\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \}$ evaluated at sumcheck challenge point
#[derive(Clone, Debug, PartialEq, CanonicalSerialize, CanonicalDeserialize)]
pub struct LinearizationProof<NTT: OverField> {
    /// * linearization_sumcheck - A list of non-interactive sumcheck prover messages
    /// * Sent in step 2 of linearization subprotocol
    pub linearization_sumcheck: sumcheck::Proof<NTT>,
    /// * The MLE of $\hat{\mathbf{f}}$ evaluated at the sumcheck challenge point
    /// * Sent in the step 3 of linearization subprotocol.
    pub v: Vec<NTT>,
    /// * The MLEs of $\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \}$ evaluated at sumcheck challenge point.
    /// * Sent in the step 3 of linearization subprotocol.
    pub u: Vec<NTT>,
}

///Prover for the linearization subprotocol
pub trait LinearizationProver<NTT: SuitableRing, T: Transcript<NTT>> {
    /// Generates a proof for the linearization subprotocol
    ///
    /// # Arguments
    ///
    /// * `cm_i` - A reference to a `CCCS<C, NTT>`, which represents a CCS statement and a commitment to a witness.
    /// * `wit` - A reference to a `Witness<NTT>` representing a CCS witness.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` - A reference to a Customizable Constraint System instance.
    ///
    /// # Returns
    ///
    /// * `Ok((LCCCS<C, NTT>, LinearizationProof<NTT>))` - On success, returns a tuple where:
    ///   * `LCCCS<C, NTT>` is a linearized version of the CCS witness commitment.
    ///   * `LinearizationProof<NTT>` is a proof that the linearization subprotocol was executed correctly.

    ///
    /// # Errors
    ///
    /// Returns an error if asked to evaluate MLEs with incorrect number of variables
    /// 
    fn prove<const C: usize>(
        cm_i: &CCCS<C, NTT>,
        wit: &Witness<NTT>,
        transcript: &mut impl Transcript<NTT>,
        ccs: &CCS<NTT>,
    ) -> Result<(LCCCS<C, NTT>, LinearizationProof<NTT>), LinearizationError<NTT>>;
}

/// Verifier for the linearization subprotocol.
pub trait LinearizationVerifier<NTT: OverField, T: Transcript<NTT>> {
    /// Verifies a proof for the linearization subprotocol. 
    /// 
    /// # Arguments
    ///
    /// * `cm_i` - A reference to a `CCCS<C, NTT>`, which represents a CCS statement and a commitment to a witness.
    /// * `proof` - A reference to a `LinearizationProof<NTT>` containing the linearization proof.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` - A reference to a Customizable Constraint System instance used in the protocol.
    ///
    /// # Returns
    ///
    /// * `Ok(LCCCS<C, NTT>)` - On success, returns a linearized version of the CCS witness commitment.
    /// * `Err(LinearizationError<NTT>)` - If verification fails, returns a `LinearizationError<NTT>`.
    ///
    fn verify<const C: usize>(
        cm_i: &CCCS<C, NTT>,
        proof: &LinearizationProof<NTT>,
        transcript: &mut impl Transcript<NTT>,
        ccs: &CCS<NTT>,
    ) -> Result<LCCCS<C, NTT>, LinearizationError<NTT>>;
}

/// The LatticeFold prover
///
/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct LFLinearizationProver<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}

/// The LatticeFold verifier
///
/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct LFLinearizationVerifier<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}
