use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::marker::PhantomData;

use cyclotomic_rings::rings::SuitableRing;

use crate::{
    arith::{Witness, CCCS, CCS, LCCCS},
    ark_base::*,
    nifs::error::LinearizationError,
    transcript::Transcript,
    utils::sumcheck,
};

use lattirust_ring::OverField;

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages.
/// * `v` - The MLE of `wit.f_hat` evaluated at the sumcheck challenge point.
/// * `u` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
#[derive(Clone, Debug, PartialEq, CanonicalSerialize, CanonicalDeserialize)]
pub struct LinearizationProof<NTT: OverField> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub linearization_sumcheck: sumcheck::Proof<NTT>,
    /// The evaluations of MLE's of the rows of $\hat{\mathbf{f}}$-matrices of the witness at the sumcheck challenge point, i.e.
    ///
    /// $$
    /// \text{v[i]}= \text{mle}[\text{wit.f\\_hat[i]}] (\mathbf{r}).
    /// $$
    ///
    /// Sent in the step 3 of linearization subprotocol.
    pub v: Vec<NTT>,
    /// The evaluations of MLE's of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ at evaluated at the sumcheck challenge point, i.e.
    ///
    /// $$
    /// \text{u[j]} =  \sum\_{\vec{\mathbf{b}} \in \\{0,1\\}^{\log n\_c}}
    /// \text{mle}[\text{ccs.M[j]}](\vec{\mathbf{x}}, \vec{\mathbf{b}}) \cdot \text{mle}\[\mathbf{z}\](\vec{\mathbf{b}}).
    /// $$
    ///
    /// Sent in the step 3 of linearization subprotocol.
    pub u: Vec<NTT>,
}

/// Prover for the linearization subprotocol
pub trait LinearizationProver<NTT: SuitableRing, T: Transcript<NTT>> {
    /// Generates a proof for the linearization subprotocol
    ///
    /// # Arguments
    ///
    /// * `cm_i` - A reference to a committed CCS statement to be linearized, i.e. a CCCS<C, NTT>.
    /// * `wit` - A reference to a CCS witness for the statement cm_i.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` - A reference to a Customizable Constraint System circuit representation.
    ///
    /// # Returns
    ///
    /// On success, returns a tuple `(LCCCS<C, NTT>, LinearizationProof<NTT>)` where:
    ///   * `LCCCS<C, NTT>` is a linearized version of the CCS witness commitment.
    ///   * `LinearizationProof<NTT>` is a proof that the linearization subprotocol was executed correctly.
    ///
    /// # Errors
    ///
    /// Returns an error if asked to evaluate MLEs with incorrect number of variables
    ///
    fn prove<const C: usize>(
        cm_i: &CCCS<C, NTT>,
        wit: &Witness<NTT>,
        transcript: &mut impl Transcript<NTT>,
        ccs: &CCS<NTT>,
    ) -> Result<(LCCCS<C, NTT>, LinearizationProof<NTT>), LinearizationError<NTT>>;
}

/// Verifier for the linearization subprotocol.
pub trait LinearizationVerifier<NTT: OverField, T: Transcript<NTT>> {
    /// Verifies a proof for the linearization subprotocol.
    ///
    /// # Arguments
    ///
    /// * `cm_i` - A reference to a `CCCS<C, NTT>`, which represents a CCS statement and a commitment to a witness.
    /// * `proof` - A reference to a `LinearizationProof<NTT>` containing the linearization proof.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` - A reference to a Customizable Constraint System instance used in the protocol.
    ///
    /// # Returns
    ///
    /// * `Ok(LCCCS<C, NTT>)` - On success, returns a linearized version of the CCS witness commitment.
    /// * `Err(LinearizationError<NTT>)` - If verification fails, returns a `LinearizationError<NTT>`.
    ///
    fn verify<const C: usize>(
        cm_i: &CCCS<C, NTT>,
        proof: &LinearizationProof<NTT>,
        transcript: &mut impl Transcript<NTT>,
        ccs: &CCS<NTT>,
    ) -> Result<LCCCS<C, NTT>, LinearizationError<NTT>>;
}

/// The LatticeFold prover
///
/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct LFLinearizationProver<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}

/// The LatticeFold verifier
///
/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct LFLinearizationVerifier<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}
